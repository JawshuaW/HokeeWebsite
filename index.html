<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operation: Typing Thunder</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&family=UnifrakturCook:wght@700&display=swap" rel="stylesheet">
</head>
<body>
    <img class="soldier-avatar" src="https://cdn.vectorstock.com/i/500p/37/74/german-soldier-cartoon-vector-25453774.jpg" alt="German field courier illustration">
    <header class="hero">
        <div class="hero-overlay">
            <h1>Operation: Typing Thunder</h1>
            <p>Berlin, 1945. Captured and cornered, you must type forged escape reports flawlessly—three strikes and the firing squad pulls the trigger.</p>
        </div>
    </header>

    <main>
        <section id="typing-arena" class="game-area">
            <div id="player-setup" class="player-setup" role="dialog" aria-modal="true">
                <div class="player-setup-card">
                    <h2>Plan Your Escape</h2>
                    <p>Enter a codename and choose a difficulty. Each page you complete is another step toward slipping past your captors.</p>
                    <label for="player-name" class="visually-hidden">Codename</label>
                    <input id="player-name" type="text" maxlength="20" placeholder="Callsign" autocomplete="off">
                    <div class="difficulty-select" role="group" aria-label="Select escape difficulty">
                        <button type="button" class="difficulty-option" data-difficulty="easy">Easy Route • 3 reports</button>
                        <button type="button" class="difficulty-option" data-difficulty="medium">Stealth Route • 6 reports</button>
                        <button type="button" class="difficulty-option" data-difficulty="hard">Impossible Route • 9 reports</button>
                    </div>
                    <button id="start-mission" type="button">Deploy Courier</button>
                </div>
            </div>

            <div class="status-grid" aria-live="polite">
                <div class="status-block">
                    <span class="status-label">Codename</span>
                    <span id="status-name" class="status-value">—</span>
                </div>
                <div class="status-block">
                    <span class="status-label">Difficulty</span>
                    <span id="status-difficulty" class="status-value">—</span>
                </div>
                <div class="status-block">
                    <span class="status-label">Rounds Remaining</span>
                    <span id="rounds-remaining" class="status-value">—</span>
                </div>
                <div class="status-block">
                    <span class="status-label">Reports Completed</span>
                    <span id="paragraphs-completed" class="status-value">0</span>
                </div>
                <div class="status-block">
                    <span class="status-label">Strikes</span>
                    <div id="strike-track" class="strike-track" aria-label="Strikes taken">
                        <span class="strike-slot" data-slot="1"></span>
                        <span class="strike-slot" data-slot="2"></span>
                        <span class="strike-slot" data-slot="3"></span>
                    </div>
                </div>
                <div class="status-block">
                    <span class="status-label">Courier Speed</span>
                    <span id="wpm" class="status-value">0 WPM</span>
                </div>
                <div class="status-block">
                    <span class="status-label">Accuracy</span>
                    <span id="accuracy" class="status-value">100%</span>
                </div>
                <div class="status-block">
                    <span class="status-label">Total Keystrokes</span>
                    <span id="keystrokes" class="status-value">0</span>
                </div>
                <div class="status-block">
                    <span class="status-label">Corrections Logged</span>
                    <span id="corrections" class="status-value">0</span>
                </div>
                <div class="status-block">
                    <span class="status-label">Flawless Streak</span>
                    <span id="streak" class="status-value">0 keys</span>
                </div>
                <div class="status-block">
                    <span class="status-label">Best Streak</span>
                    <span id="best-streak" class="status-value">0 keys</span>
                </div>
                <div class="status-block">
                    <span class="status-label">Mission Time</span>
                    <span id="mission-clock" class="status-value">00:00</span>
                </div>
            </div>

            <div class="typewriter" aria-live="assertive">
                <div class="typewriter-body" id="typewriter">
                    <div class="typewriter-paper">
                        <div class="paper-header">Allied Dispatch • Berlin Sector</div>
                        <div id="round-banner" class="round-banner">Awaiting escape orders…</div>
                        <div class="target-line">Current transmission:</div>
                        <p id="paragraph-display" class="paragraph-display"><span id="typed-portion"></span><span id="remaining-portion"></span></p>
                        <div class="paragraph-progress" aria-hidden="true">
                            <div id="paragraph-progress-fill" class="paragraph-progress-fill"></div>
                        </div>
                        <div class="hint-line">Remember: a single wrong letter counts as a strike.</div>
                    </div>
                    <div class="typewriter-platen"></div>
                    <div class="typewriter-keys">
                        <div class="key-row"><span>Q</span><span>W</span><span>E</span><span>R</span><span>T</span><span>Y</span><span>U</span><span>I</span><span>O</span><span>P</span></div>
                        <div class="key-row"><span>A</span><span>S</span><span>D</span><span>F</span><span>G</span><span>H</span><span>J</span><span>K</span><span>L</span></div>
                        <div class="key-row"><span>Z</span><span>X</span><span>C</span><span>V</span><span>B</span><span>N</span><span>M</span></div>
                    </div>
                    <textarea id="type-input" rows="4" autocomplete="off" spellcheck="false" aria-label="Type the Allied transmission" disabled></textarea>
                </div>
            </div>

            <div id="announcement" role="status" aria-live="assertive"></div>

            <div class="battle-log">
                <h2>Radio Log</h2>
                <ul id="log-entries"></ul>
            </div>

            <div class="leaderboard">
                <div class="leaderboard-header">
                    <h2>Global Courier Leaderboard</h2>
                    <button id="clear-leaderboard" type="button">Clear Board</button>
                </div>
                <table aria-label="Global courier leaderboard">
                    <thead>
                        <tr>
                            <th scope="col">Rank</th>
                            <th scope="col">Codename</th>
                            <th scope="col">Difficulty</th>
                            <th scope="col">WPM</th>
                            <th scope="col">Accuracy</th>
                            <th scope="col">Keystrokes</th>
                            <th scope="col">Mistakes / Fixes</th>
                            <th scope="col">Reports</th>
                            <th scope="col">Time</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboard-body"></tbody>
                </table>
            </div>

            <div class="controls">
                <button id="restart-button" type="button">Request Reinforcements</button>
            </div>
        </section>
    </main>

    <footer>
        <p>&copy; 1945 Allied Command. Survive the night.</p>
    </footer>

    <iframe
        id="battle-hymn"
        class="soundtrack"
        title="Battle ambience"
        src="https://www.youtube.com/embed/h_FNt31NVLI?autoplay=1&loop=1&playlist=h_FNt31NVLI&controls=0&modestbranding=1&showinfo=0&rel=0&enablejsapi=1&mute=1"
        allow="autoplay"
        allowfullscreen>
    </iframe>

    <div id="game-over" class="game-over" aria-hidden="true">
        <div class="game-over-content">
            <h2 id="game-over-title">Mission Failed</h2>
            <p id="game-over-message"></p>
            <dl class="final-stats">
                <div>
                    <dt>WPM</dt>
                    <dd id="final-wpm">0</dd>
                </div>
                <div>
                    <dt>Accuracy</dt>
                    <dd id="final-accuracy">0%</dd>
                </div>
                <div>
                    <dt>Keystrokes</dt>
                    <dd id="final-keystrokes">0</dd>
                </div>
                <div>
                    <dt>Mistakes</dt>
                    <dd id="final-mistakes">0</dd>
                </div>
                <div>
                    <dt>Corrections</dt>
                    <dd id="final-corrections">0</dd>
                </div>
                <div>
                    <dt>Reports Completed</dt>
                    <dd id="final-paragraphs">0</dd>
                </div>
                <div>
                    <dt>Difficulty</dt>
                    <dd id="final-difficulty">—</dd>
                </div>
                <div>
                    <dt>Mission Time</dt>
                    <dd id="final-time">00:00</dd>
                </div>
            </dl>
            <button id="debrief-button" type="button">Return to Briefing</button>
        </div>
        <div class="game-over-blood"></div>
        <div class="game-over-flash"></div>
    </div>

    <script>
        (function () {
            const missions = {
                easy: {
                    rounds: 3,
                    prompts: [
                        "A sympathetic nurse slides you a smuggled typewriter and whispers that the escape tunnel will open at midnight if your report looks official.",
                        "You detail fake orders rerouting the guard patrol, praying every keystroke convinces the Kommandant.",
                        "Each word you type buys your squad more time to cut through the cellar bars beneath the barracks."
                    ]
                },
                medium: {
                    rounds: 6,
                    prompts: [
                        "Rain beats against the barrack roof while you forge an ammunition audit that will empty the watchtower just before your dash across the yard.",
                        "You recall the sergeant's handwriting from confiscated ledgers and mimic every stroke as you authorize a prisoner transfer to the rail yard.",
                        "Your fingers tremble while you invent casualty numbers, hoping the morse intercept team trusts the forged seal.",
                        "The tunnel diggers wait for your cue; you describe a phony medical quarantine that will seal off the infirmary corridor.",
                        "Shellfire rattles the windows as you encode coordinates for a non-existent inspection that should lure the guards away.",
                        "You fold in rumors about Allied advances, padding your report with enough fear to earn an evacuation order.",
                        "Your bunkmate stands lookout as you assign the night shift to a guard already detained for questioning."
                    ]
                },
                hard: {
                    rounds: 9,
                    prompts: [
                        "Floodlights sweep the yard while you craft a meticulous requisition log, matching every serial number stolen from last week's munitions shipment.",
                        "You adjust the carriage with bloodied knuckles, documenting a fabricated Gestapo summons that demands the camp commandant's presence in Berlin.",
                        "Cold wind knifes through the cracks as you cite invented chemical leaks, referencing the manual you memorized during interrogation.",
                        "The radio crackles with enemy chatter while you weave a forged order relocating half the guard platoon to reinforce a collapsing bridge.",
                        "Prisoners crowd around the latrine tunnel, hanging on your words as you authorize a false prisoner exchange set for dawn.",
                        "Every keystroke echoes in the silent barracks while you imitate the colonel's clipped cadence to request emergency transport vehicles.",
                        "You embed subtle code phrases in the margins, assuring the resistance that the east fence will be unguarded after roll call.",
                        "The typewriter ribbon begins to fray, yet you outline a supply shortage severe enough to justify unlocking the armory.",
                        "Mortars thud in the distance as you finalize evacuation manifests that will put every guard on the road by nightfall."
                    ]
                }
            };
            const difficultyNames = {
                easy: 'Easy Route',
                medium: 'Stealth Route',
                hard: 'Impossible Route'
            };

            const statusDifficulty = document.getElementById('status-difficulty');
            const roundsRemainingDisplay = document.getElementById('rounds-remaining');
            const paragraphsCompleted = document.getElementById('paragraphs-completed');
            const strikeTrack = document.getElementById('strike-track');
            const wpmDisplay = document.getElementById('wpm');
            const accuracyDisplay = document.getElementById('accuracy');
            const keystrokesDisplay = document.getElementById('keystrokes');
            const correctionsDisplay = document.getElementById('corrections');
            const streakDisplay = document.getElementById('streak');
            const bestStreakDisplay = document.getElementById('best-streak');
            const missionClock = document.getElementById('mission-clock');
            const typedPortion = document.getElementById('typed-portion');
            const remainingPortion = document.getElementById('remaining-portion');
            const progressFill = document.getElementById('paragraph-progress-fill');
            const announcement = document.getElementById('announcement');
            const logEntries = document.getElementById('log-entries');
            const typewriter = document.getElementById('typewriter');
            const typeInput = document.getElementById('type-input');
            const startButton = document.getElementById('start-mission');
            const playerNameInput = document.getElementById('player-name');
            const playerSetup = document.getElementById('player-setup');
            const statusName = document.getElementById('status-name');
            const roundBanner = document.getElementById('round-banner');
            const restartButton = document.getElementById('restart-button');
            const debriefButton = document.getElementById('debrief-button');
            const gameOverPanel = document.getElementById('game-over');
            const gameOverTitle = document.getElementById('game-over-title');
            const gameOverMessage = document.getElementById('game-over-message');
            const finalWpm = document.getElementById('final-wpm');
            const finalAccuracy = document.getElementById('final-accuracy');
            const finalKeystrokes = document.getElementById('final-keystrokes');
            const finalMistakes = document.getElementById('final-mistakes');
            const finalCorrections = document.getElementById('final-corrections');
            const finalParagraphs = document.getElementById('final-paragraphs');
            const finalDifficulty = document.getElementById('final-difficulty');
            const finalTime = document.getElementById('final-time');
            const leaderboardBody = document.getElementById('leaderboard-body');
            const clearLeaderboardButton = document.getElementById('clear-leaderboard');
            const soundtrackFrame = document.getElementById('battle-hymn');
            const difficultyButtons = document.querySelectorAll('.difficulty-option');
            let pendingDifficulty = 'easy';

            const MAX_LEADERBOARD = 10;

            const state = {
                playerName: '',
                difficulty: null,
                roundGoal: 0,
                roundIndex: 0,
                strikes: 0,
                paragraphsDelivered: 0,
                totalCorrectChars: 0,
                mistakes: 0,
                keystrokes: 0,
                corrections: 0,
                activeParagraph: '',
                usedParagraphs: [],
                startTime: null,
                elapsedInterval: null,
                gameActive: false,
                errorIndex: null,
                lockedValue: '',
                currentStreak: 0,
                longestStreak: 0,
                lastMatchLength: 0
            };

            let soundtrackUnlocked = false;
            function postToSoundtrack(message) {
                if (!soundtrackFrame || !soundtrackFrame.contentWindow) {
                    return;
                }
                soundtrackFrame.contentWindow.postMessage(JSON.stringify(message), '*');
            }

            function activateSoundtrack() {
                if (!soundtrackFrame) {
                    return;
                }
                postToSoundtrack({ event: 'command', func: 'playVideo', args: [] });
            }

            function unmuteSoundtrack() {
                if (soundtrackUnlocked) {
                    return;
                }
                soundtrackUnlocked = true;
                postToSoundtrack({ event: 'command', func: 'unMute', args: [] });
                postToSoundtrack({ event: 'command', func: 'setVolume', args: [100] });
                postToSoundtrack({ event: 'command', func: 'playVideo', args: [] });
            }

            if (soundtrackFrame) {
                soundtrackFrame.addEventListener('load', activateSoundtrack);
            }

            function sampleParagraph() {
                if (!state.difficulty || !missions[state.difficulty]) {
                    return '';
                }
                const pool = missions[state.difficulty].prompts;
                if (!pool || pool.length === 0) {
                    return '';
                }
                if (state.usedParagraphs.length >= pool.length) {
                    state.usedParagraphs = [];
                }
                let candidate;
                let safety = 0;
                do {
                    candidate = pool[Math.floor(Math.random() * pool.length)];
                    safety += 1;
                } while (state.usedParagraphs.includes(candidate) && safety < 20);
                state.usedParagraphs.push(candidate);
                return candidate;
            }

            function formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
                const seconds = String(totalSeconds % 60).padStart(2, '0');
                return `${minutes}:${seconds}`;
            }

            function computeWpm(correctOverride) {
                if (!state.startTime) {
                    return 0;
                }
                const elapsedMinutes = Math.max((performance.now() - state.startTime) / 60000, 1 / 60);
                const correct = typeof correctOverride === 'number' ? correctOverride : state.totalCorrectChars;
                return (correct / 5) / elapsedMinutes;
            }

            function computeAccuracy(correctOverride, mistakeOverride) {
                const correct = typeof correctOverride === 'number' ? correctOverride : state.totalCorrectChars;
                const mistakes = typeof mistakeOverride === 'number' ? mistakeOverride : state.mistakes;
                const total = correct + mistakes;
                if (total === 0) {
                    return 100;
                }
                return (correct / total) * 100;
            }

            function updateStrikeDisplay() {
                [...strikeTrack.children].forEach((slot, index) => {
                    slot.classList.toggle('active', index < state.strikes);
                });
            }

            function updateStats(currentMatchLength = state.lastMatchLength) {
                const effectiveCorrect = state.totalCorrectChars + currentMatchLength;
                const mistakes = state.mistakes;
                const roundsLeft = Math.max(state.roundGoal - state.roundIndex, 0);
                roundsRemainingDisplay.textContent = state.roundGoal ? roundsLeft : '—';
                paragraphsCompleted.textContent = state.roundIndex;
                statusDifficulty.textContent = difficultyNames[state.difficulty] || '—';
                wpmDisplay.textContent = `${computeWpm(effectiveCorrect).toFixed(1)} WPM`;
                accuracyDisplay.textContent = `${computeAccuracy(effectiveCorrect, mistakes).toFixed(1)}%`;
                keystrokesDisplay.textContent = state.keystrokes;
                correctionsDisplay.textContent = state.corrections;
                streakDisplay.textContent = `${state.currentStreak} keys`;
                bestStreakDisplay.textContent = `${state.longestStreak} keys`;
                updateStrikeDisplay();
            }

            function updateTimer() {
                if (!state.startTime) {
                    missionClock.textContent = '00:00';
                    return;
                }
                missionClock.textContent = formatTime(performance.now() - state.startTime);
            }

            function updateRoundBanner() {
                roundBanner.classList.remove('success', 'failure');
                if (!state.gameActive || !state.roundGoal) {
                    roundBanner.textContent = 'Awaiting escape orders…';
                    return;
                }
                const current = Math.min(state.roundIndex + 1, state.roundGoal);
                roundBanner.textContent = `Report ${current} of ${state.roundGoal}`;
            }

            function setParagraph(text) {
                state.activeParagraph = text;
                typedPortion.textContent = '';
                remainingPortion.textContent = text;
                typeInput.value = '';
                typewriter.style.setProperty('--typed-length', 0);
                typeInput.focus();
                state.errorIndex = null;
                state.lockedValue = '';
                state.lastMatchLength = 0;
                updateProgress(0, text.length);
                updateRoundBanner();
            }

            function logEvent(message, variant = 'neutral') {
                const entry = document.createElement('li');
                entry.textContent = message;
                entry.className = variant;
                logEntries.prepend(entry);
                while (logEntries.children.length > 8) {
                    logEntries.removeChild(logEntries.lastChild);
                }
            }

            function setAnnouncement(message, variant) {
                announcement.textContent = message;
                announcement.className = variant;
            }

            function resetTypewriterAnimation() {
                typewriter.classList.remove('shake');
                void typewriter.offsetWidth;
            }

            function recordStrike(currentMatchLength = state.lastMatchLength) {
                state.strikes += 1;
                state.mistakes += 1;
                state.currentStreak = 0;
                updateStats(currentMatchLength);
                resetTypewriterAnimation();
                typewriter.classList.add('shake');
                logEvent('A guard narrows his eyes at the forged document.', 'danger');
                if (state.strikes >= 3) {
                    endGame(false);
                }
            }

            function completeReport(charsTyped) {
                state.totalCorrectChars += charsTyped;
                state.lastMatchLength = 0;
                state.roundIndex += 1;
                state.paragraphsDelivered = state.roundIndex;
                state.currentStreak = 0;
                const roundsLeft = Math.max(state.roundGoal - state.roundIndex, 0);
                if (roundsLeft > 0) {
                    logEvent(`Report ${state.roundIndex} delivered. ${roundsLeft} more until the escape is ready.`, 'success');
                } else {
                    logEvent(`Final report delivered. The escape plan is complete!`, 'success');
                }
                updateStats();
                if (state.roundIndex >= state.roundGoal) {
                    endGame(true);
                    return;
                }
                setParagraph(sampleParagraph());
            }

            function resetGameState(options = {}) {
                const preserveDifficulty = Boolean(options.preserveDifficulty);
                if (!preserveDifficulty) {
                    state.difficulty = null;
                    state.roundGoal = 0;
                }
                state.roundIndex = 0;
                state.paragraphsDelivered = 0;
                state.strikes = 0;
                state.totalCorrectChars = 0;
                state.mistakes = 0;
                state.keystrokes = 0;
                state.corrections = 0;
                state.activeParagraph = '';
                state.usedParagraphs = [];
                state.startTime = null;
                if (state.elapsedInterval) {
                    clearInterval(state.elapsedInterval);
                    state.elapsedInterval = null;
                }
                state.gameActive = false;
                state.errorIndex = null;
                state.lockedValue = '';
                state.currentStreak = 0;
                state.longestStreak = 0;
                state.lastMatchLength = 0;
                missionClock.textContent = '00:00';
                typedPortion.textContent = '';
                remainingPortion.textContent = '';
                announcement.textContent = '';
                announcement.className = '';
                logEntries.innerHTML = '';
                updateProgress(0, 1);
                updateStats();
                updateTimer();
                updateStrikeDisplay();
                typeInput.setAttribute('disabled', 'disabled');
                roundsRemainingDisplay.textContent = state.roundGoal ? state.roundGoal : '—';
                paragraphsCompleted.textContent = 0;
                if (!preserveDifficulty) {
                    statusDifficulty.textContent = '—';
                }
                roundBanner.textContent = 'Awaiting escape orders…';
                roundBanner.classList.remove('success', 'failure');
            }

            function startMission() {
                const trimmedName = playerNameInput.value.trim();
                if (!trimmedName) {
                    playerNameInput.focus();
                    return;
                }
                const chosenDifficulty = pendingDifficulty && missions[pendingDifficulty] ? pendingDifficulty : 'easy';
                const missionProfile = missions[chosenDifficulty];
                if (!missionProfile) {
                    return;
                }
                state.difficulty = chosenDifficulty;
                state.roundGoal = missionProfile.rounds;
                resetGameState({ preserveDifficulty: true });
                state.playerName = trimmedName;
                statusName.textContent = trimmedName;
                statusDifficulty.textContent = difficultyNames[state.difficulty] || '—';
                playerSetup.classList.add('hidden');
                typeInput.removeAttribute('disabled');
                state.gameActive = true;
                state.startTime = null;
                setParagraph(sampleParagraph());
                setAnnouncement('Forged orders ready. Keep your cover by typing flawlessly.', 'info');
                logEvent(`Escape difficulty locked: ${difficultyNames[state.difficulty]} — ${state.roundGoal} reports to freedom.`, 'neutral');
                logEvent('You sit at the barrack desk and begin forging your escape papers.', 'neutral');
                updateStats();
                updateTimer();
                unmuteSoundtrack();
            }

            function endGame(victory) {
                state.gameActive = false;
                typeInput.setAttribute('disabled', 'disabled');
                if (state.elapsedInterval) {
                    clearInterval(state.elapsedInterval);
                    state.elapsedInterval = null;
                }
                const elapsed = state.startTime ? performance.now() - state.startTime : 0;
                const totalCorrect = state.totalCorrectChars + state.lastMatchLength;
                const wpm = computeWpm(totalCorrect);
                const accuracy = computeAccuracy(totalCorrect, state.mistakes);
                const timeLabel = formatTime(elapsed);
                finalWpm.textContent = wpm.toFixed(1);
                finalAccuracy.textContent = `${accuracy.toFixed(1)}%`;
                finalKeystrokes.textContent = state.keystrokes;
                finalMistakes.textContent = state.mistakes;
                finalCorrections.textContent = state.corrections;
                finalParagraphs.textContent = state.paragraphsDelivered;
                finalDifficulty.textContent = difficultyNames[state.difficulty] || '—';
                finalTime.textContent = timeLabel;

                const summary = {
                    name: state.playerName,
                    wpm: Number(wpm.toFixed(2)),
                    accuracy: Number(accuracy.toFixed(2)),
                    keystrokes: state.keystrokes,
                    mistakes: state.mistakes,
                    corrections: state.corrections,
                    paragraphs: state.paragraphsDelivered,
                    time: timeLabel,
                    difficulty: state.difficulty,
                    timestamp: Date.now()
                };
                updateLeaderboard(summary);

                if (victory) {
                    setAnnouncement('Freedom! Your forged reports fooled every guard.', 'victory');
                    logEvent('The resistance smuggles you beyond the camp walls.', 'success');
                    gameOverTitle.textContent = 'Escape Successful';
                    gameOverMessage.textContent = `The escape tunnel opens and ${state.playerName} disappears into the Berlin night.`;
                    roundBanner.textContent = 'Freedom secured!';
                    roundBanner.classList.remove('failure');
                    roundBanner.classList.add('success');
                    gameOverPanel.classList.remove('fatal');
                } else {
                    setAnnouncement('Alarms blare. The guards close in on your cell.', 'defeat');
                    logEvent('The commandant tears up your forged papers and orders the firing squad.', 'danger');
                    gameOverTitle.textContent = 'Escape Failed';
                    gameOverMessage.textContent = `Three mistakes exposed your plan, ${state.playerName}. The attempt ends here.`;
                    roundBanner.textContent = 'Captured under guard.';
                    roundBanner.classList.remove('success');
                    roundBanner.classList.add('failure');
                    gameOverPanel.classList.add('fatal');
                }

                gameOverPanel.setAttribute('aria-hidden', 'false');
                gameOverPanel.classList.add('visible');
            }

            function hideGameOver() {
                gameOverPanel.classList.remove('visible');
                gameOverPanel.setAttribute('aria-hidden', 'true');
            }

            function handleKeydown(event) {
                if (event.key === 'Enter' || event.key === 'Tab') {
                    event.preventDefault();
                }
                if (!state.gameActive) {
                    return;
                }
                if (event.metaKey || event.ctrlKey || event.altKey) {
                    return;
                }
                if (event.key.length === 1 || event.key === 'Backspace' || event.key === 'Delete') {
                    state.keystrokes += 1;
                    updateStats();
                }
            }

            function handleInput() {
                if (!state.gameActive) {
                    typeInput.value = '';
                    return;
                }
                let typed = typeInput.value;
                const expected = state.activeParagraph;
                if (!state.startTime) {
                    state.startTime = performance.now();
                    if (!state.elapsedInterval) {
                        state.elapsedInterval = setInterval(updateTimer, 250);
                    }
                }
                if (state.errorIndex !== null) {
                    const locked = state.lockedValue;
                    if ((typed.length > locked.length && typed.startsWith(locked)) || (typed.length === locked.length && typed !== locked)) {
                        typeInput.value = locked;
                        typed = locked;
                    }
                }

                let matchLength = 0;
                let mismatch = null;
                const limit = Math.min(typed.length, expected.length);
                for (let i = 0; i < limit; i++) {
                    if (typed[i] !== expected[i]) {
                        mismatch = {
                            index: i,
                            expectedChar: expected[i] ?? null,
                            typedChar: typed[i] ?? ''
                        };
                        break;
                    }
                }
                if (mismatch) {
                    matchLength = mismatch.index;
                } else {
                    matchLength = limit;
                    if (typed.length > expected.length) {
                        mismatch = {
                            index: expected.length,
                            expectedChar: null,
                            typedChar: typed[expected.length] ?? '',
                            overflow: true
                        };
                    }
                }

                renderParagraph(matchLength, mismatch);
                typewriter.style.setProperty('--typed-length', matchLength);
                updateProgress(matchLength, expected.length);

                if (mismatch) {
                    if (state.errorIndex === null) {
                        state.errorIndex = matchLength;
                        state.lockedValue = typed;
                        recordStrike(matchLength);
                        setAnnouncement('You mis-typed a letter! Backspace before the guard notices.', 'warning');
                    } else {
                        if (typed.length <= state.errorIndex && expected.startsWith(typed)) {
                            state.errorIndex = null;
                            state.lockedValue = typed;
                            state.corrections += 1;
                            logEvent('Error corrected. Fingers steady.', 'success');
                            setAnnouncement('Error cleared. Continue the deception.', 'info');
                        } else {
                            state.lockedValue = typed;
                        }
                    }
                    state.lastMatchLength = matchLength;
                    updateStats(matchLength);
                    return;
                }

                if (state.errorIndex !== null) {
                    if (typed.length <= state.errorIndex && expected.startsWith(typed)) {
                        state.errorIndex = null;
                        state.lockedValue = typed;
                        state.corrections += 1;
                        logEvent('Error corrected. Fingers steady.', 'success');
                        setAnnouncement('Error cleared. Continue the deception.', 'info');
                    } else {
                        typeInput.value = state.lockedValue;
                        updateStats(matchLength);
                        return;
                    }
                }

                const gained = matchLength - state.lastMatchLength;
                if (gained > 0) {
                    state.currentStreak += gained;
                    if (state.currentStreak > state.longestStreak) {
                        state.longestStreak = state.currentStreak;
                    }
                } else if (matchLength < state.lastMatchLength) {
                    state.currentStreak = matchLength;
                }
                state.lastMatchLength = matchLength;

                updateStats(matchLength);
                state.lockedValue = typed;

                if (typed === expected) {
                    completeReport(expected.length);
                    if (state.gameActive) {
                        setAnnouncement('Report accepted. Prepare the next forged order.', 'success');
                    }
                    state.lockedValue = '';
                    typewriter.classList.add('success');
                    setTimeout(() => typewriter.classList.remove('success'), 400);
                }
            }

            function handleRestart() {
                hideGameOver();
                resetGameState();
                playerSetup.classList.remove('hidden');
                playerNameInput.value = state.playerName;
                playerNameInput.focus();
            }

            function loadLeaderboard() {
                try {
                    const stored = localStorage.getItem('typingThunderLeaderboard');
                    if (!stored) {
                        return [];
                    }
                    return JSON.parse(stored);
                } catch (error) {
                    console.error('Failed to read leaderboard', error);
                    return [];
                }
            }

            function persistLeaderboard(entries) {
                try {
                    localStorage.setItem('typingThunderLeaderboard', JSON.stringify(entries));
                } catch (error) {
                    console.error('Failed to persist leaderboard', error);
                }
            }

            function renderLeaderboard(entries) {
                leaderboardBody.innerHTML = '';
                entries.forEach((entry, index) => {
                    const row = document.createElement('tr');
                    const wpm = typeof entry.wpm === 'number' ? entry.wpm : 0;
                    const accuracy = typeof entry.accuracy === 'number' ? entry.accuracy : 0;
                    const keystrokes = typeof entry.keystrokes === 'number' ? entry.keystrokes : 0;
                    const mistakes = typeof entry.mistakes === 'number' ? entry.mistakes : 0;
                    const corrections = typeof entry.corrections === 'number' ? entry.corrections : 0;
                    const paragraphs = typeof entry.paragraphs === 'number' ? entry.paragraphs : 0;
                    const difficultyLabel = difficultyNames[entry.difficulty] || (typeof entry.difficulty === 'string' ? entry.difficulty : '—');
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${entry.name}</td>
                        <td>${difficultyLabel}</td>
                        <td>${wpm.toFixed(1)}</td>
                        <td>${accuracy.toFixed(1)}%</td>
                        <td>${keystrokes}</td>
                        <td>${mistakes} / ${corrections}</td>
                        <td>${paragraphs}</td>
                        <td>${entry.time}</td>
                    `;
                    leaderboardBody.appendChild(row);
                });
                if (entries.length === 0) {
                    const emptyRow = document.createElement('tr');
                    const cell = document.createElement('td');
                    cell.colSpan = 9;
                    cell.textContent = 'No records yet. Deliver your first dispatch to claim the top spot.';
                    emptyRow.appendChild(cell);
                    leaderboardBody.appendChild(emptyRow);
                }
            }

            function updateLeaderboard(summary) {
                const entries = loadLeaderboard();
                entries.push(summary);
                entries.sort((a, b) => {
                    if (b.wpm !== a.wpm) {
                        return b.wpm - a.wpm;
                    }
                    if (b.accuracy !== a.accuracy) {
                        return b.accuracy - a.accuracy;
                    }
                    const mistakesA = typeof a.mistakes === 'number' ? a.mistakes : Number.MAX_SAFE_INTEGER;
                    const mistakesB = typeof b.mistakes === 'number' ? b.mistakes : Number.MAX_SAFE_INTEGER;
                    if (mistakesA !== mistakesB) {
                        return mistakesA - mistakesB;
                    }
                    if (b.paragraphs !== a.paragraphs) {
                        return b.paragraphs - a.paragraphs;
                    }
                    const keystrokesA = typeof a.keystrokes === 'number' ? a.keystrokes : 0;
                    const keystrokesB = typeof b.keystrokes === 'number' ? b.keystrokes : 0;
                    if (keystrokesB !== keystrokesA) {
                        return keystrokesB - keystrokesA;
                    }
                    const correctionsA = typeof a.corrections === 'number' ? a.corrections : 0;
                    const correctionsB = typeof b.corrections === 'number' ? b.corrections : 0;
                    if (correctionsB !== correctionsA) {
                        return correctionsB - correctionsA;
                    }
                    return (a.timestamp || 0) - (b.timestamp || 0);
                });
                const trimmed = entries.slice(0, MAX_LEADERBOARD);
                persistLeaderboard(trimmed);
                renderLeaderboard(trimmed);
            }

            function clearLeaderboard() {
                persistLeaderboard([]);
                renderLeaderboard([]);
            }

            difficultyButtons.forEach((button, index) => {
                if (index === 0) {
                    button.classList.add('selected');
                }
                button.addEventListener('click', () => {
                    const chosen = button.dataset.difficulty;
                    if (!chosen || !missions[chosen]) {
                        return;
                    }
                    pendingDifficulty = chosen;
                    difficultyButtons.forEach((btn) => btn.classList.toggle('selected', btn === button));
                });
            });

            startButton.addEventListener('click', startMission);
            playerNameInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    startMission();
                }
            });
            typeInput.addEventListener('keydown', handleKeydown);
            typeInput.addEventListener('input', handleInput);
            typeInput.addEventListener('paste', (event) => event.preventDefault());
            restartButton.addEventListener('click', handleRestart);
            debriefButton.addEventListener('click', handleRestart);
            clearLeaderboardButton.addEventListener('click', () => {
                clearLeaderboard();
                logEvent('Resistance archive wiped clean.', 'neutral');
            });
            document.addEventListener('click', () => {
                if (state.gameActive) {
                    typeInput.focus();
                }
                unmuteSoundtrack();
            });

            document.addEventListener('keydown', () => {
                unmuteSoundtrack();
            }, { once: false });

            renderLeaderboard(loadLeaderboard());
            updateStats();
            updateTimer();
            playerNameInput.focus();

            function renderParagraph(matchLength, mismatch) {
                typedPortion.innerHTML = '';
                remainingPortion.innerHTML = '';

                const correctText = state.activeParagraph.slice(0, matchLength);
                if (correctText) {
                    const correctSpan = document.createElement('span');
                    correctSpan.className = 'typed-correct';
                    correctSpan.textContent = correctText;
                    typedPortion.appendChild(correctSpan);
                }

                if (mismatch) {
                    if (typeof mismatch.typedChar === 'string') {
                        const typedSpan = document.createElement('span');
                        typedSpan.className = 'typed-mismatch';
                        typedSpan.textContent = mismatch.typedChar === '' ? '∎' : mismatch.typedChar;
                        typedPortion.appendChild(typedSpan);
                    }

                    const expectedSpan = document.createElement('span');
                    expectedSpan.className = 'expected-mismatch';
                    const expectedChar = mismatch.expectedChar === null ? '∎' : mismatch.expectedChar;
                    expectedSpan.textContent = expectedChar;
                    remainingPortion.appendChild(expectedSpan);

                    const restIndex = mismatch.expectedChar === null ? mismatch.index : mismatch.index + 1;
                    const rest = state.activeParagraph.slice(restIndex);
                    if (rest) {
                        remainingPortion.appendChild(document.createTextNode(rest));
                    }
                } else {
                    remainingPortion.textContent = state.activeParagraph.slice(matchLength);
                }

                if (!typedPortion.hasChildNodes()) {
                    typedPortion.textContent = '';
                }
            }

            function updateProgress(matchLength, totalLength) {
                const percent = totalLength ? Math.min(100, (matchLength / totalLength) * 100) : 0;
                progressFill.style.width = `${percent}%`;
            }
        })();
    </script>
</body>
</html>
